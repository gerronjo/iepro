//////////////////////////////////////////////////////////////////////////////
// pacgen on github:
// https://github.com/zzydog/iepro/master/pacgen.py
// This pac file is generated by pacgen. (at ${gentime})

//////////////////////////////////////////////////////////////////////////////
var _i2p = "PROXY 127.0.0.1:4444";			// i2p proxy
var _tor = "SOCKS5 127.0.0.1:9150";			// tor proxy
var _http = "PROXY 127.0.0.1:8080";			// normal proxy
var _socks = "SOCKS 127.0.0.1:1080";		// normal proxy
var _privoxy = "PROXY 127.0.0.1:8118";		// privoxy proxy
var _freegate = "PROXY 127.0.0.1:8580";		// freegate proxy
var _ultrasurf = "PROXY 127.0.0.1:9666";	// ultrasurf proxy
var _shadowsocks = "SOCKS5 127.0.0.1:9999";	// shadowsocks proxy


//////////////////////////////////////////////////////////////////////////////
var _proxylist = ${proxylist};			// The proxy list
var _domainlist = ${domainlist};		// The domain list
var _keywordlist = ${keywordlist};		// The keyword list
//////////////////////////////////////////////////////////////////////////////
var _drop = ${drop};	// 5 -> drop the request
var _proxy = ${proxy};	// 2 -> proxy 
var _direct = ${direct};			// 1 -> connect directly
var _prenull = null;						// 0 -> default value 
var _randomly = null;						// 3 -> select randomly 
var _anonymous = _tor + '; ' + _i2p;		// 4 -> anonymous proxy 
// Internet Explorer does not support socks proxy, 
// so you need to translate it to http proxy protocol 
// e.g. privoxy, polipo
var _methodlist = [null, _direct, _proxy, 0, _anonymous, _drop];
function GetProxyMethod(index) {
	// select the proxy from the proxylist randomly
	if (index >= _methodlist.length) return null;
	else if (index != 3) 
		return index in _methodlist ? _methodlist[index] : _direct;
	return _proxylist[Math.floor(Math.random()*_proxylist.length)];
}
//////////////////////////////////////////////////////////////////////////////
function error(key, reason, value) {
	alert("[pacgen] " +key+ " -> " +reason+ ": " + value); 
}
function GetMeta(metalist, url, host, domain) {
	for (var i = 0; i < metalist.length; ++i) {
		meta = metalist[i];	// get the meta data
		switch (meta[0]) {
		case 0:
			if (meta[1] == null) return meta[2];
			if (meta[1] == true)
				if (host == domain) return meta[2];
			else if (meta[1] == false)
				if (host != domain) return meta[2];
			break;
		case 1:
			if (isInNetEx(dnsResolve(host), meta[1]))
				return meta[2]; 
			break;
		case 5:
			var re = meta[1];
			// build the regular expressions dynamicly
			if (typeof(re) == 'string') {
				re = new RegExp(re, 'i'); meta[1] = re;
			}
			if (re.test(url)) { return meta[2]; }
			break;
		case 2:
			var lv = dnsDomainLevels(host);
			var low = meta[1] & 0x7f;
			var high = meta[1] >> 8 & 0x7f;
			if (lv >= low && lv <= high) return meta[2];
			break;
		case 4:
			if (shExpMatch(url, meta[1])) return meta[2];
			break;
		case 3:
			if (url.indexOf(meta[1]) >= 0) return meta[2];
			break;
		default: error(host, "invalid opcode", meta[0]); break;
		}
	}
}
function GetDomainMeta(url, host, domain) {
	var metalist = _domainlist[domain];	// get the meta list
	// meta -> opcode, params, return
	try {
		if (metalist == null) return null;
		return GetMeta(metalist, url, host, domain);
	} catch (err) { 
		error("GetDomainMeta", err.name, err.message); return null;
	}
}
function GetKeywordMeta(url, host, domain) {
	// meta -> opcode, params, return
	try {
		return GetMeta(_keywordlist, url, host, host);
	} catch (err) { 
		error("GetKeywordMeta", err.name, err.message); return null;
	}
}


//////////////////////////////////////////////////////////////////////////////
// The path and query components of https:// URLs are stripped. 
// In Chrome, you can disable this by setting 
// PacHttpsUrlStrippingEnabled to false, in Firefox the preference 
// is network.proxy.autoconfig_url.include_path.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/
// Proxy_servers_and_tunneling/Proxy_Auto-Configuration_(PAC)_file
function FindProxyForURL (url, host) {
	var domain, result, pos = 0;
	// check if it's the local host.
	// avoid leaking local domain name
	if (isPlainHostName(host)) return _direct;
	if (shExpMatch(host, "*.local")) return _direct;
	do {
		domain = host.substring(pos + 0);
		result = GetDomainMeta(url, host, domain);
		if (result != null) return GetProxyMethod(result);
		pos = host.indexOf('.', pos + 1) + 1; // find the next domain
	} while (pos > 0);
	// We can't find a match in domain rule set, try keyword rule set
	result = GetKeywordMeta(url, host, host);
	return (result == null ? _direct : GetProxyMethod(result)); // done!
}
